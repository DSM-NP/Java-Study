1. Java 원시코드(.java)를 Java complier가 Java Bytecode(*.class)로 변환한다.
    - Java complier는 JDK 설치 시 bin에 존재하는 javac.exe이다. 따라서 javac 명령어를 통해 .java파일을 .class 파일로 컴파일이 가능하다. (JDK안에 Java complier 존재)
    - Java 원시코드(.java)는 사람에게 친화적인 언어로 작성되어 있기 때문에 CPU가 인식을 하지 못한다.
    - Java는 JVM을 걸쳐 OS에 도달하기 때문에 OS가 인식가능한 기계어로 바로 컴파일 되는 것이 아닌 JVM이 인식가능한 Java Bytecode(*.class)로 변환된다.
2. 컴파일 된 바이트 코드를 JVM의 Class roader에게 전달한다.
3. 클래스 로더는 Dynamic Loading을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(JVM의 메모리)에 올린다.
    - 클래스 로더 세부 동작
        - 로드: 클래스 파일을 가져와서 JVM의 메모리에 로드한다.
        - 검증: Java Language Specification(자바 언어 명세) 및 JVM 명세에 명시된대로 구성되어 있는 검사한다.
        - 준비: 클래스가 필요로 하는 메모리를 할당한다. (필드, 메소드, 인터페이스 등등)
        - 분석: 클래스의 [상수 풀](https://hueco.tistory.com/387) 내 모든 Symbolic references를 Direct references로 변경한다.
            - Symbolic references: 참고하는 클래스의 특정 메모리 주소를 참조 관계로 구성한 것이 아닌 참조하는 대상의 이름만을 지칭한 것.
            - Direct references: 이름에 맞는 객체의 주소를 찾아서 연결하는 것.
        - 초기화: 클래스 변수들을 적절한 값으로 초기화한다. (static 필드)
4. Execution Engine(실행 엔진)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다. 
    - 인터프리터: 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나하나의 실행은 빠르나 전체적인 실행속도가 느리다는 단점이 있다.
    - JIT(Just In Time) Compiler: 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메소드를 인터프리팅(자바 컴파일러를 통해 생성된 클래스파일을 기계어로 변환)하지 않고 바이너리 코드로 직접 실행하는 방식이다. 하나씩 인터프리팅하여 실행하는 것이 아닌 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 방식이기 때문에 전체적인 실행속도는 인터프리터보다 빠르다.
        - JIT Complier는 Dynamic translation이라고도 한다.
        - JIT Complier는 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일하여 기계어로 번경하고 이후에는 더 이상 인터프리팅 하지 않고 기계어로 직접 실행하는 방식.
        - 기계어(컴파일 된 코드)는 캐시에 보관하기 때문에 한 번 컴파일 된 코드는 빠르게 실행된다.
        - JIT Complier가 컴파일하는 과정은 바이트 코드를 인터프리팅하는 것보다 매우 오래걸리므로 한 번만 실행되는 코드라면 컴파일 하지 않고 인터프리팅하는 것이 더 유리하다.
        - JIT Complier를 사용하는 JVM들은 내부적으로 해당 메소드가 얼마나 자주 수행되는지 체크하고 일정 정도를 넣을 때에만 컴파일을 수행한다.
    

Java는 자바 컴파일러가 자바 프로그램 코드를 바이트 코드로 변환한 다음 실제 바이트 코드를 실행하는 시점에서 JVM(정확히는 JRE)이 바이트 코드를 JIT 컴파일러을 통해 기계어로 변환하는 것이다.
